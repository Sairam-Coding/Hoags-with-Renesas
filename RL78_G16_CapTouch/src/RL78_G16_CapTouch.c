/***********************************************************************************************************************
* DISCLAIMER
* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products.
* No other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
* applicable laws, including copyright laws. 
* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED
* OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY
* LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE FOR ANY DIRECT,
* INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR
* ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability 
* of this software. By using this software, you agree to the additional terms and conditions found by accessing the 
* following link:
* http://www.renesas.com/disclaimer
*
* Copyright (C) 2020 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/

/***********************************************************************************************************************
*  File Name    : RL78_G16_CapTouch.c
*  Description  : Main Program
*  Creation Date: 2024-08-30
*  This file was generated by Smart Configurator.
***********************************************************************************************************************/
#include "r_smc_entry.h"
#include<string.h>
void qe_touch_main(void);
int main (void);

void uart_integer(int);

__saddr unsigned int g_pulse_width[4];    /* Store pulse width */
unsigned char g_times;   /* Measurement times counter */

__saddr unsigned int g_pulse_width1[4];    /* Store pulse width */
unsigned char g_times1;   /* Measurement times counter */

unsigned char confirmed;
unsigned char comvar;

int flag1=0,flag2=0;

uint8_t var=' ';
uint32_t pulse_width;

int main(void)
{
    R_Config_UART1_Create();
	R_Config_UART1_Start();
	R_Config_TAU0_2_Create();
	R_Config_TAU0_2_Start();
	R_Config_TAU0_3_Create();
	R_Config_TAU0_3_Start();
	R_Config_TAU0_0_Create();
	R_Config_TAU0_0_Start();
	g_times = 4U;
    EI();
    qe_touch_main();
    while(1)
    {
    	HALT();
    }
    //return 0;
}

void uart_integer(int num)
{
	char arr[10];
	int i=0;
	while(num)
	{
		arr[i]=(num%10)+48;
		num/=10;
		i++;
	}
	for(i--;i>=0;i--)
	{
		R_Config_UART1_Send(arr+i,1);
		R_BSP_SoftwareDelay(10,BSP_DELAY_MILLISECS);
	}
	//R_BSP_SoftwareDelay(20,BSP_DELAY_MILLISECS);
	R_Config_UART1_Send(&var,1);
}

void TASK1(void)
{

	if(g_times==0)
	{
//		for(int i=0;i<4;i++)
//		    {
//		    	uart_integer(g_pulse_width[i]);
//		    	R_BSP_SoftwareDelay(500,BSP_DELAY_MILLISECS);
//		    }
		if((g_pulse_width[1] > 3000 && g_pulse_width[2] > 2000 && g_pulse_width[3] > 3000)   ||  (g_pulse_width[1] > 2000 && g_pulse_width[2] > 3000 && g_pulse_width[3] > 2000 ))
			PIN_WRITE(1,2)=~PIN_READ(1,2);
		flag1=1;
		memset(g_pulse_width,'\0',4);
		R_Config_TAU0_2_Start();
		EI();
		g_times=4U;
	}
	if(g_times1==0)
	{
		flag2=1;
		if((g_pulse_width1[1] > 3000 && g_pulse_width1[2] > 2000 && g_pulse_width1[3] > 3000)   ||  (g_pulse_width1[1] > 2000 && g_pulse_width1[2] > 3000 && g_pulse_width1[3] > 2000 ))
		PIN_WRITE(1,2)=~PIN_READ(1,2);
		memset(g_pulse_width1,'\0',4);
				R_Config_TAU0_3_Start();
				EI();
				g_times1=4U;
	}
//	if(flag1==1 && flag2==0)
//	{
//			if((g_pulse_width1[1] > 3000 && g_pulse_width1[2] > 2000 && g_pulse_width1[3] > 3000)   ||  (g_pulse_width1[1] > 2000 && g_pulse_width1[2] > 3000 && g_pulse_width1[3] > 2000 ))
//			PIN_WRITE(1,2)=~PIN_READ(1,2);
//			flag1=0,flag2=0;
//			uart_integer(64);
//	}
}

//extern __saddr unsigned int g_pulse_width[8];    /* Store pulse width */
//extern unsigned char g_times;                      /* Measurement times counter */
//g_pulse_width[8U - g_times] = g_tau0_ch0_width;    /* Store capture value */
//
//   if (0U == ( --g_times))        /* 8 times measurement finished ? */
//   {
//       R_Config_TAU0_0_Stop();    /* Stops timer counter */
//   }
